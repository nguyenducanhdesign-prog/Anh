import { GoogleGenAI, Modality, Part, Type } from "@google/genai";

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY! });

// Simple check for Vietnamese characters.
const isVietnamese = (text: string) => /[àáâãèéêìíòóôõùúăđĩũơư]/i.test(text);

const fileToGenerativePart = async (file: File): Promise<Part> => {
  const base64EncodedDataPromise = new Promise<string>((resolve) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve((reader.result as string).split(',')[1]);
    reader.readAsDataURL(file);
  });
  return {
    inlineData: { data: await base64EncodedDataPromise, mimeType: file.type },
  };
};

export const editImage = async (
  prompt: string, 
  imageFile: File, 
  temperature: number = 0.4, // Default to a balanced temperature
  referenceFile?: File
): Promise<{ imageUrls: string[], textResponse: string }> => {
  if (!prompt || !imageFile) {
    throw new Error("Prompt and image are required.");
  }
  
  try {
    const imagePart = await fileToGenerativePart(imageFile);
    const parts: Part[] = [imagePart];

    if (referenceFile) {
        const referencePart = await fileToGenerativePart(referenceFile);
        parts.push({text: "Use the following image as a style reference: "});
        parts.push(referencePart);
    }
    
    // Auto-translation prompt wrapper for Vietnamese
    let finalPrompt = prompt;
    if(isVietnamese(prompt)) {
        finalPrompt = `Please translate the following Vietnamese prompt to English and then apply it to the main image. Do not include the translation in your text response, only the edited image. The prompt is: "${prompt}"`;
    }

    parts.push({ text: finalPrompt });
    
    const contents = { parts };

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image-preview',
      contents: contents,
      config: {
          responseModalities: [Modality.IMAGE, Modality.TEXT],
          temperature: temperature,
      },
    });

    const imageUrls: string[] = [];
    let textResponse = '';

    if (response.candidates && response.candidates.length > 0) {
        for (const part of response.candidates[0].content.parts) {
            if (part.text) {
                textResponse += part.text;
            } else if (part.inlineData) {
                const base64ImageBytes: string = part.inlineData.data;
                const imageUrl = `data:${part.inlineData.mimeType};base64,${base64ImageBytes}`;
                imageUrls.push(imageUrl);
            }
        }
    }
    
    if (imageUrls.length === 0) {
        if (textResponse) {
            throw new Error(`Image generation failed: ${textResponse}`);
        }
        throw new Error("No image was generated by the AI.");
    }

    return { imageUrls, textResponse };

  } catch (error) {
    console.error("Error editing image with Gemini:", error);
    if (error instanceof Error) {
        throw new Error(`Failed to edit image: ${error.message}`);
    }
    throw new Error("An unknown error occurred while editing the image.");
  }
};

export const describeImage = async (
  imageFile: File
): Promise<{ english: string, vietnamese: string }> => {
  if (!imageFile) {
    throw new Error("An image is required for description.");
  }

  try {
    const imagePart = await fileToGenerativePart(imageFile);

    const generateDescription = async (prompt: string): Promise<string> => {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts: [imagePart, { text: prompt }] },
            config: {
                temperature: 0.3,
            },
        });
        return response.text.trim();
    };

    const englishPrompt = "Generate a short, concise description of this image's key aspects. Focus only on: style, color tone, lighting, and the main subject.";
    const vietnamesePrompt = "Tạo một mô tả ngắn gọn, súc tích về các khía cạnh chính của hình ảnh này. Chỉ tập trung vào: phong cách, tông màu, ánh sáng và chủ thể chính.";
    
    const [english, vietnamese] = await Promise.all([
      generateDescription(englishPrompt),
      generateDescription(vietnamesePrompt)
    ]);

    if (!english || !vietnamese) {
        throw new Error("AI failed to generate a complete description.");
    }
    
    return { english, vietnamese };

  } catch (error) {
    console.error("Error describing image with Gemini:", error);
    if (error instanceof Error) {
        throw new Error(`Failed to describe image: ${error.message}`);
    }
    throw new Error("An unknown error occurred while describing the image.");
  }
};


export const upscaleImage = async (
  imageFile: File,
  scaleFactor: 2 | 4
): Promise<{ imageUrls: string[], textResponse: string }> => {
  if (!imageFile) {
    throw new Error("An image is required for upscaling.");
  }
  
  try {
    const imagePart = await fileToGenerativePart(imageFile);
    
    // A prompt specifically for upscaling and enhancing details.
    const upscalePrompt = `Please upscale this image to ${scaleFactor}x its original resolution. Enhance the details, sharpness, and clarity without altering the original content or style. Make it look like a high-resolution photograph.`;

    const parts: Part[] = [imagePart, { text: upscalePrompt }];
    const contents = { parts };

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image-preview',
      contents: contents,
      config: {
          responseModalities: [Modality.IMAGE, Modality.TEXT],
          temperature: 0.2, // Low temperature for less creative changes
      },
    });

    const imageUrls: string[] = [];
    let textResponse = '';

    if (response.candidates && response.candidates.length > 0) {
        for (const part of response.candidates[0].content.parts) {
            if (part.text) {
                textResponse += part.text;
            } else if (part.inlineData) {
                const base64ImageBytes: string = part.inlineData.data;
                const imageUrl = `data:${part.inlineData.mimeType};base64,${base64ImageBytes}`;
                imageUrls.push(imageUrl);
            }
        }
    }
    
    if (imageUrls.length === 0) {
        if (textResponse) {
            throw new Error(`Upscale failed: ${textResponse}`);
        }
        throw new Error("No upscaled image was generated by the AI.");
    }

    return { imageUrls, textResponse };

  } catch (error) {
    console.error("Error upscaling image with Gemini:", error);
    if (error instanceof Error) {
        throw new Error(`Failed to upscale image: ${error.message}`);
    }
    throw new Error("An unknown error occurred while upscaling the image.");
  }
};

export const generateQuickActions = async (
  imageFile?: File,
  existingActions?: string[]
): Promise<{ title: string; prompt: string }[]> => {
  try {
    const parts: Part[] = [];

    let textPrompt = `You are an expert creative assistant for an AI image editor.
Generate 10 creative, short, and actionable editing ideas that can be appended to a user's prompt.
Provide the response as a valid JSON array of objects. Each object must have two keys: "title" (a 2-3 word button label) and "prompt" (the text to append).
The "prompt" should be a comma-separated list of keywords or a short descriptive phrase.

Example format:
[
  {"title": "80s Film Look", "prompt": "80s vintage film aesthetic, grainy, slight color fade"},
  {"title": "Neon Glow", "prompt": "cyberpunk neon glow, vibrant colors, dark background"}
]
`;

    if (imageFile) {
      const imagePart = await fileToGenerativePart(imageFile);
      parts.push(imagePart);
      textPrompt += "\nBase these suggestions on the content of the provided image.";
    } else {
      textPrompt += "\nThese should be generic suggestions suitable for any type of image.";
    }

    if (existingActions && existingActions.length > 0) {
      textPrompt += `\nCRITICAL: The following suggestions have already been shown. Do NOT repeat them or provide very similar ideas. Be original.\nExisting suggestions: ${JSON.stringify(existingActions)}`;
    }
    
    parts.push({ text: textPrompt });

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: { parts },
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              title: { type: Type.STRING },
              prompt: { type: Type.STRING },
            },
            required: ['title', 'prompt'],
          },
        },
        temperature: 0.8,
      },
    });

    const text = response.text.trim();

    // Handle cases where the response is empty (e.g., blocked by safety filters)
    if (!text) {
        const candidate = response.candidates?.[0];
        if (candidate?.finishReason && candidate.finishReason !== 'STOP') {
            throw new Error(`AI generation failed. Reason: ${candidate.finishReason}.`);
        }
        throw new Error("AI returned an empty response. This could be due to safety filters or a network issue.");
    }
    
    // Robustly find and extract the JSON array from the response string.
    // This handles cases where the model might wrap the JSON in markdown ```json ... ```
    const startIndex = text.indexOf('[');
    const endIndex = text.lastIndexOf(']');
    
    // If no JSON array is found, the model might have responded with text (e.g., a refusal).
    if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
        console.warn("Gemini response did not contain a JSON array:", text);
        // Truncate the response to avoid a huge error message.
        const preview = text.length > 150 ? `${text.substring(0, 150)}...` : text;
        throw new Error(`AI returned a non-JSON response: "${preview}"`);
    }
    
    const jsonString = text.substring(startIndex, endIndex + 1);

    try {
        const result = JSON.parse(jsonString);
        return result as { title: string; prompt: string }[];
    } catch(parseError) {
        console.error("Failed to parse JSON string from Gemini:", jsonString, parseError);
        throw new Error("AI returned a malformed JSON object that could not be parsed.");
    }

  } catch (error) {
    console.error("Error generating quick actions with Gemini:", error);
    if (error instanceof Error) {
      throw new Error(`Failed to generate suggestions: ${error.message}`);
    }
    throw new Error("An unknown error occurred while generating suggestions.");
  }
};